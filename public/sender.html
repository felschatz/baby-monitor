<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Baby Monitor - Sender</title>
    <link rel="stylesheet" href="/sender.css">
</head>
<body>
    <!-- Session prompt overlay -->
    <div class="session-overlay" id="sessionOverlay">
        <div class="session-prompt">
            <h2>Enter Session Name</h2>
            <p>Use a unique name to connect sender and receiver</p>
            <input type="text" id="sessionInput" placeholder="e.g., felix-baby" autocomplete="off" autocapitalize="none">
            <button class="btn btn-start" id="sessionJoinBtn">Join Session</button>
            <p class="session-hint">Bookmark the URL after joining for easy daily access</p>
        </div>
    </div>

    <!-- Screen off overlay -->
    <div class="screen-off-overlay" id="screenOffOverlay">
        <div class="tap-hint">Tap to wake</div>
    </div>

    <!-- Dim countdown indicator -->
    <div class="dim-indicator" id="dimIndicator">
        Screen dimming soon...
        <div class="countdown-bar" id="countdownBar"></div>
    </div>

    <div class="header">
        <a href="/" class="back-link">‚Üê</a>
        <h2>Baby's Phone</h2>
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Disconnected</span>
            <span class="quality-badge" id="qualityBadge"></span>
        </div>
    </div>

    <div class="video-container">
        <video id="localVideo" autoplay muted playsinline></video>
        <!-- Hidden audio element for PTT playback -->
        <audio id="pttAudio" autoplay></audio>
    </div>

    <!-- PTT indicator -->
    <div class="ptt-indicator" id="pttIndicator">
        üîä Parent is speaking...
    </div>

    
    <!-- Music indicator -->
    <div class="music-indicator" id="musicIndicator">
        üéµ <span id="musicTrackName">Playing music...</span>
        <div class="music-timer" id="musicTimer"></div>
    </div>

    <!-- Hidden audio element for music playback -->
    <audio id="musicAudio"></audio>

    <!-- Music controls (local) -->
    <div class="music-controls-panel" id="musicControlsPanel" style="display: none;">
        <div class="music-controls-row">
            <button class="music-btn" id="musicBtn">üéµ</button>
            <select class="music-playlist-select" id="musicPlaylistSelect" title="Select playlist"></select>
            <select class="music-timer-select" id="musicTimerSelect">
                <option value="45">45 min</option>
                <option value="60">1 hour</option>
            </select>
            <button class="music-reset-btn" id="musicResetBtn" style="display: none;">Reset</button>
        </div>
        <div class="music-volume-row">
            <span>üîä</span>
            <input type="range" id="musicVolume" min="0" max="100" value="50">
            <span id="musicVolumeValue">50%</span>
        </div>
        <div class="music-label" id="musicLabel">Play lullabies</div>
    </div>

    <div class="controls">
        <div class="options" id="optionsPanel">
            <label class="option">
                <input type="checkbox" id="enableVideo" checked>
                <span>Video</span>
            </label>
            <label class="option">
                <input type="checkbox" id="enableAudio" checked>
                <span>Audio</span>
            </label>
        </div>

        <div class="streaming-status" id="streamingStatus" style="display: none;">
            <span class="status-label">Sending:</span>
            <span class="status-value" id="streamingStatusValue">Video + Audio</span>
        </div>

        <div class="audio-meter">
            <div class="audio-level" id="audioLevel"></div>
        </div>

        <button class="btn btn-start" id="startBtn">Start Streaming</button>
        <button class="btn btn-stop" id="stopBtn" style="display: none;">Stop Streaming</button>

        <div class="info" id="info">
            Click "Start Streaming" to begin broadcasting
        </div>
    </div>

    <script>
        // Session handling
        const sessionOverlay = document.getElementById('sessionOverlay');
        const sessionInput = document.getElementById('sessionInput');
        const sessionJoinBtn = document.getElementById('sessionJoinBtn');

        // Extract session from URL path: /s/mysession
        const pathMatch = window.location.pathname.match(/^\/s\/(.+)$/);
        let sessionName = pathMatch ? decodeURIComponent(pathMatch[1]) : null;

        // Extract quality setting from URL: ?q=sd or ?q=hd (default: hd)
        const urlParams = new URLSearchParams(window.location.search);
        const videoQuality = urlParams.get('q') === 'sd' ? 'sd' : 'hd';

        if (!sessionName) {
            // No session in URL - show prompt
            sessionOverlay.style.display = 'flex';

            // Pre-fill from localStorage if available
            const savedSession = localStorage.getItem('babymonitor-session');
            if (savedSession) {
                sessionInput.value = savedSession;
            }

            sessionJoinBtn.addEventListener('click', joinSession);
            sessionInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinSession();
            });
        } else {
            // Session in URL - save to localStorage and proceed
            localStorage.setItem('babymonitor-session', sessionName);
            sessionOverlay.style.display = 'none';
        }

        function joinSession() {
            const name = sessionInput.value.trim();
            if (!name) {
                sessionInput.focus();
                return;
            }
            // Redirect to session URL, preserving quality parameter
            window.location.href = `/s/${encodeURIComponent(name)}?q=${videoQuality}`;
        }

        // Don't run the rest of the code if no session
        if (!sessionName) {
            // Stop execution here - user needs to enter session first
            throw new Error('Session required');
        }

        // Display quality badge
        const qualityBadge = document.getElementById('qualityBadge');
        qualityBadge.textContent = videoQuality.toUpperCase();
        qualityBadge.classList.add(videoQuality);

        // ========== ROBUST KEEP-AWAKE SYSTEM ==========
        // Multiple fallback mechanisms to prevent phone from sleeping

        let wakeLock = null;
        let wakeLockInterval = null;
        let noSleepVideo = null;
        let keepAliveAudio = null;
        let lastWakeLockLog = 0;

        function wakeLockLog(msg) {
            const now = Date.now();
            if (now - lastWakeLockLog >= 5000) {
                console.log(msg);
                lastWakeLockLog = now;
            }
        }

        async function requestWakeLock() {
            // Release existing lock first to avoid leaks
            if (wakeLock) {
                try {
                    await wakeLock.release();
                } catch (e) {}
                wakeLock = null;
            }

            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLockLog('Wake lock acquired');

                    // Listen for release events (OS can release anytime)
                    wakeLock.addEventListener('release', () => {
                        wakeLockLog('Wake lock released by system, re-acquiring...');
                        // Small delay to avoid rapid re-acquisition loops
                        setTimeout(requestWakeLock, 1000);
                    });
                }
            } catch (err) {
                console.log('Wake lock failed:', err.message);
            }
        }

        // Periodic wake lock refresh (every 30 seconds)
        function startWakeLockRefresh() {
            if (wakeLockInterval) clearInterval(wakeLockInterval);
            wakeLockInterval = setInterval(() => {
                if (document.visibilityState === 'visible') {
                    wakeLockLog('Periodic wake lock refresh');
                    requestWakeLock();
                }
            }, 30000);
        }

        // NoSleep.js technique: hidden video that keeps screen awake
        function createNoSleepVideo() {
            if (noSleepVideo) return;

            // Minimal valid MP4 (from NoSleep.js) - works across browsers
            const mp4Data = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAAu1tZGF0AAACrQYF//+p3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0xIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDM6MHgxMTMgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTEgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz0xIGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MyBiX3B5cmFtaWQ9MiBiX2FkYXB0PTEgYl9iaWFzPTAgZGlyZWN0PTEgd2VpZ2h0Yj0xIG9wZW5fZ29wPTAgd2VpZ2h0cD0yIGtleWludD0yNTAga2V5aW50X21pbj0yNSBzY2VuZWN1dD00MCBpbnRyYV9yZWZyZXNoPTAgcmNfbG9va2FoZWFkPTQwIHJjPWNyZiBtYnRyZWU9MSBjcmY9MjMuMCBxY29tcD0wLjYwIHFwbWluPTAgcXBtYXg9NjkgcXBzdGVwPTQgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAABZliIQD/2T/g4AAAE6AAAMOj/kj4AADABAAAAFBmiRsQ/8AAAANQZokbEP/AAAADUGaRGxD/wAAAA1BmmRsQ/8AAAANQZqEbEP/AAAADUGapGxD/wAAAA1BmsRsQ/8AAAANQZrkbEP/AAAADUGbBGxD/wAAAA1BmyRsQ/8AAAANQZtEbEP/AAAAC0GbY0OYQ/8AAAADQZ+CRRUsM/8AAAADQZoEnQAAAANBmiSdAAAAA0GaRJ0AAAADQZpknQAAAANBmoSdAAAAA0GapJ0AAAADQZrEnQAAAANBmuSdAAAAA0GbBJ0AAAADQZsknQAAAANBm0SdAAAAA0GbZJ0AAAACAERlAAADkW1vb3YAAABsbXZoZAAAAAAAAAAAAAAAAAAAA+gAAAPoAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAALAdHJhawAAAFx0a2hkAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAPoAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAQAAAAEAAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAAAD6AAAAAAAAQAAAAABmW1kaWEAAAAgbWRoZAAAAAAAAAAAAAAAAAAAfQAAfQBVxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAABRG1pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAARRzdGJsAAAAlHN0c2QAAAAAAAAAAQAAAIRhdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAABAAEABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBZAAK/+EAF2dkAAqs2UJE3AAADwAAfQeDxgxlgAEABmjr4AAQfgAADA9YAAAAF2NvbHJuY2x4AAYAAQAGAAAAAAASc3R0cwAAAAAAAAABAAAADwAAfQAAAAAUc3RzcwAAAAAAAAABAAAAAQAAADhjdHRzAAAAAAAAAA8AAAABAAABfgAAAAEAAAPvAAAAAQAAAX4AAAABAAAAAAAAAAEAAAPoAAAAAQAAAX4AAAABAAAAAAAAAAEAAAPoAAAAAQAAAX4AAAABAAAAAAAAAAEAAAPoAAAAAQAAAX4AAAABAAAAAAAAAAEAR3N0c2MAAAAAAAAAAQAAAAEAAAAPAAAAAQAAAEhzdHN6AAAAAAAAAAAAAAAPAAABAQAAAA0AAAANAAAADQAAAAsAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAFHN0Y28AAAAAAAAAAQAAADAAAABidWR0YQAAAFptZXRhAAAAAAAAACFoZGxyAAAAAAAAAABtZGlyYXBwbAAAAAAAAAAAAAAAAC1pbHN0AAAAJal0b28AAAAdZGF0YQAAAAEAAAAATGF2ZjU2LjQwLjEwMQ==';

            noSleepVideo = document.createElement('video');
            noSleepVideo.setAttribute('playsinline', '');
            noSleepVideo.setAttribute('muted', '');
            noSleepVideo.muted = true; // Also set property for some browsers
            noSleepVideo.setAttribute('loop', '');
            noSleepVideo.style.cssText = 'position:fixed;top:-1px;left:-1px;width:1px;height:1px;opacity:0.01;pointer-events:none;';
            noSleepVideo.src = mp4Data;
            document.body.appendChild(noSleepVideo);

            // Try to play (may need user interaction first)
            noSleepVideo.play().catch(() => {
                console.log('NoSleep video needs user interaction');
            });
        }

        // Silent audio keep-alive (plays inaudible tone)
        function createKeepAliveAudio() {
            if (keepAliveAudio) return;

            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                // Inaudible: 1Hz at zero volume
                oscillator.frequency.value = 1;
                gainNode.gain.value = 0.001; // Nearly silent

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();

                keepAliveAudio = { audioCtx, oscillator, gainNode };
                console.log('Keep-alive audio started');
            } catch (err) {
                console.log('Keep-alive audio failed:', err.message);
            }
        }

        // Initialize all keep-awake mechanisms
        function initKeepAwake() {
            requestWakeLock();
            startWakeLockRefresh();
            createNoSleepVideo();
            // Audio keep-alive started after user interaction (below)
        }

        // Re-acquire on visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                wakeLockLog('Page visible, refreshing keep-awake');
                requestWakeLock();
                if (noSleepVideo) {
                    noSleepVideo.play().catch(() => {});
                }
            }
        });

        // Start keep-awake on first user interaction (needed for video/audio autoplay)
        document.addEventListener('click', function initOnInteraction() {
            createKeepAliveAudio();
            if (noSleepVideo) {
                noSleepVideo.play().catch(() => {});
            }
            document.removeEventListener('click', initOnInteraction);
        }, { once: true });

        initKeepAwake();
        // ========== END KEEP-AWAKE SYSTEM ==========

        // Screen dimming functionality
        const screenOffOverlay = document.getElementById('screenOffOverlay');
        const dimIndicator = document.getElementById('dimIndicator');
        const countdownBar = document.getElementById('countdownBar');

        const DIM_TIMEOUT = 5000; // 5 seconds
        const WARNING_TIME = 2000; // Show warning 2 seconds before dimming
        let dimTimer = null;
        let warningTimer = null;
        let countdownInterval = null;
        let isScreenOff = false;

        function resetDimTimer() {
            // Clear existing timers
            clearTimeout(dimTimer);
            clearTimeout(warningTimer);
            clearInterval(countdownInterval);

            // Hide the indicator
            dimIndicator.classList.remove('visible');
            countdownBar.style.width = '100%';

            // If screen is off, wake it up
            if (isScreenOff) {
                wakeScreen();
                return;
            }

            // Start warning timer (shows indicator before screen dims)
            warningTimer = setTimeout(() => {
                showDimWarning();
            }, DIM_TIMEOUT - WARNING_TIME);

            // Start dim timer
            dimTimer = setTimeout(() => {
                dimScreen();
            }, DIM_TIMEOUT);
        }

        function showDimWarning() {
            dimIndicator.classList.add('visible');
            countdownBar.style.width = '100%';

            let remaining = WARNING_TIME;
            const step = 50; // Update every 50ms

            countdownInterval = setInterval(() => {
                remaining -= step;
                const percent = (remaining / WARNING_TIME) * 100;
                countdownBar.style.width = percent + '%';

                if (remaining <= 0) {
                    clearInterval(countdownInterval);
                }
            }, step);
        }

        function dimScreen() {
            isScreenOff = true;
            screenOffOverlay.classList.add('active');
            dimIndicator.classList.remove('visible');
            clearInterval(countdownInterval);
        }

        function wakeScreen() {
            isScreenOff = false;
            screenOffOverlay.classList.remove('active');
            resetDimTimer();
        }

        // Wake screen on overlay tap
        screenOffOverlay.addEventListener('click', wakeScreen);
        screenOffOverlay.addEventListener('touchstart', wakeScreen);

        // Reset timer on any user interaction
        const interactionEvents = ['mousedown', 'mousemove', 'touchstart', 'touchmove', 'scroll', 'keydown'];
        interactionEvents.forEach(event => {
            document.addEventListener(event, () => {
                if (!isScreenOff) {
                    resetDimTimer();
                }
            }, { passive: true });
        });

        // Start the dim timer
        resetDimTimer();

        // SSE and WebRTC (no WebSockets!)
        let eventSource = null;
        let localStream = null;
        let peerConnection = null;
        let audioContext = null;
        let analyser = null;
        let pendingCandidates = [];

        const localVideo = document.getElementById('localVideo');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const info = document.getElementById('info');
        const audioLevel = document.getElementById('audioLevel');
        const enableVideo = document.getElementById('enableVideo');
        const enableAudio = document.getElementById('enableAudio');
        const pttAudio = document.getElementById('pttAudio');
        const pttIndicator = document.getElementById('pttIndicator');
        const optionsPanel = document.getElementById('optionsPanel');
        const streamingStatus = document.getElementById('streamingStatus');
        const streamingStatusValue = document.getElementById('streamingStatusValue');

        // PTT timeout - fallback to hide indicator if no stop message received
        let pttTimeout = null;
        const PTT_TIMEOUT_MS = 30000; // 30 seconds max PTT duration
        
        // PTT active flag - controlled by server messages, not track events
        let pttActive = false;
        
        // Auto-streaming flags
        let isStreaming = false;
        let sseConnected = false;

        // Video state requested by receiver (for bandwidth saving)
        let receiverWantsVideo = true;

        // Music player state
        const musicAudio = document.getElementById('musicAudio');
        const musicIndicator = document.getElementById('musicIndicator');
        const musicTrackName = document.getElementById('musicTrackName');
        const musicTimerEl = document.getElementById('musicTimer');
        const musicControlsPanel = document.getElementById('musicControlsPanel');
        const musicBtn = document.getElementById('musicBtn');
        const musicPlaylistSelect = document.getElementById('musicPlaylistSelect');
        const musicTimerSelect = document.getElementById('musicTimerSelect');
        const musicResetBtn = document.getElementById('musicResetBtn');
        const musicVolumeSlider = document.getElementById('musicVolume');
        const musicVolumeValue = document.getElementById('musicVolumeValue');
        const musicLabel = document.getElementById('musicLabel');
        let musicPlaylist = [];
        let musicPlaylists = []; // Available playlist folders
        let currentPlaylistId = localStorage.getItem('sender-music-playlist') || '1'; // Default to playlist 1
        let musicShuffled = [];
        let musicCurrentIndex = 0;
        let musicPlaying = false;
        let musicTimer = null;
        let musicTimerRemaining = 0;
        let musicStatusInterval = null;

        // Echo cancellation (spectral subtraction) state
        let echoCancelEnabled = false;  // User preference from receiver
        let echoCancelActive = false;   // Actually processing
        let musicMediaSource = null;    // MediaElementSource for music (can only create once)
        let echoProcessorNode = null;   // ScriptProcessorNode for processing
        let echoStreamDestination = null; // Output for WebRTC
        let echoMicSource = null;       // Mic source node (must keep reference to prevent GC)
        let echoMusicAnalyser = null;   // FFT analyzer for music
        let originalAudioTrack = null;  // Original mic track for restore
        let processedAudioTrack = null; // Processed track for WebRTC

        // FFT-based spectral subtraction parameters
        const FFT_SIZE = 2048;              // Frequency resolution (1024 bins)
        const HOP_SIZE = 1024;              // 50% overlap
        const ALPHA = 2.0;                  // Over-subtraction factor (reduces musical noise)
        const BETA = 0.02;                  // Spectral floor (prevents artifacts)
        const SMOOTHING = 0.6;              // Temporal smoothing between frames
        const MUSIC_SCALE = 0.7;            // Scale music magnitude for acoustic path
        const PROCESSOR_BUFFER_SIZE = 4096; // Processing buffer size
        const MAX_OVERRUNS = 10;            // Fallback to simple mode after this many

        // FFT state (initialized when echo cancellation starts)
        let fftState = null;

        // Load saved music volume from localStorage
        const savedMusicVolume = localStorage.getItem('sender-music-volume');
        if (savedMusicVolume !== null) {
            musicVolumeSlider.value = savedMusicVolume;
            musicVolumeValue.textContent = savedMusicVolume + '%';
            musicAudio.volume = parseInt(savedMusicVolume) / 100;
        } else {
            musicAudio.volume = 0.5; // Default 50%
        }

        // Music volume control
        musicVolumeSlider.addEventListener('input', () => {
            const value = musicVolumeSlider.value;
            musicAudio.volume = value / 100;
            musicVolumeValue.textContent = value + '%';
            localStorage.setItem('sender-music-volume', value);
        });

        // Local music toggle
        function toggleMusicLocal() {
            if (musicPlaying) {
                fadeOutAndStop();
            } else {
                const timerMinutes = parseInt(musicTimerSelect.value);
                startMusic(timerMinutes);
            }
        }

        // Update music controls UI
        function updateMusicControlsUI() {
            if (musicPlaying) {
                musicBtn.textContent = '‚èπÔ∏è';
                musicBtn.classList.add('active');
                musicLabel.textContent = 'Stop music';
                musicResetBtn.style.display = 'inline-block';
            } else {
                musicBtn.textContent = 'üéµ';
                musicBtn.classList.remove('active');
                musicLabel.textContent = 'Play lullabies';
                musicResetBtn.style.display = 'none';
            }
        }

        // Music button click handler
        musicBtn.addEventListener('click', toggleMusicLocal);

        // Reset timer button click handler
        musicResetBtn.addEventListener('click', () => {
            if (!musicPlaying) return;
            const timerMinutes = parseInt(musicTimerSelect.value);
            console.log('Resetting music timer to', timerMinutes, 'minutes');
            musicTimerRemaining = timerMinutes * 60;
            updateMusicTimerDisplay();
            broadcastMusicStatus();
        });

        // Fetch available music files for a specific playlist
        async function fetchMusicPlaylist(playlistId = null) {
            try {
                const playlist = playlistId || currentPlaylistId;
                const response = await fetch(`/api/music?playlist=${encodeURIComponent(playlist)}`);
                const data = await response.json();
                musicPlaylist = data.files || [];
                musicPlaylists = data.playlists || [];

                console.log('Music playlist loaded:', musicPlaylist.length, 'tracks from playlist', playlist);
                console.log('Available playlists:', musicPlaylists);

                // Populate playlist dropdown if we have multiple playlists
                if (musicPlaylists.length > 0) {
                    musicPlaylistSelect.innerHTML = '';
                    musicPlaylists.forEach(p => {
                        const option = document.createElement('option');
                        option.value = p.id;
                        option.textContent = p.name;
                        if (p.id === playlist) option.selected = true;
                        musicPlaylistSelect.appendChild(option);
                    });
                    musicPlaylistSelect.style.display = 'inline-block';

                    // If saved playlist doesn't exist, default to first available (usually "1")
                    const playlistIds = musicPlaylists.map(p => p.id);
                    if (!playlistIds.includes(currentPlaylistId)) {
                        currentPlaylistId = musicPlaylists[0].id;
                        localStorage.setItem('sender-music-playlist', currentPlaylistId);
                        // Refetch for the correct playlist
                        return fetchMusicPlaylist(currentPlaylistId);
                    }
                } else {
                    // No playlist subdirectories, hide the selector
                    musicPlaylistSelect.style.display = 'none';
                }

                // Show music controls if tracks available
                if (musicPlaylist.length > 0 || musicPlaylists.length > 0) {
                    musicControlsPanel.style.display = 'block';
                }

                // Add debug timer option if enabled (only once)
                if (data.debugTimer && !musicTimerSelect.querySelector('option[value="1"]')) {
                    const debugOption = document.createElement('option');
                    debugOption.value = '1';
                    debugOption.textContent = '1 min (debug)';
                    musicTimerSelect.insertBefore(debugOption, musicTimerSelect.firstChild);
                }
            } catch (err) {
                console.error('Failed to fetch music playlist:', err);
                musicPlaylist = [];
            }
        }

        // Handle playlist selection change
        musicPlaylistSelect.addEventListener('change', () => {
            currentPlaylistId = musicPlaylistSelect.value;
            localStorage.setItem('sender-music-playlist', currentPlaylistId);
            console.log('Switched to playlist:', currentPlaylistId);

            // If music is playing, stop it before switching
            if (musicPlaying) {
                stopMusic(true);
            }

            // Fetch tracks for the new playlist
            fetchMusicPlaylist(currentPlaylistId);
        });

        // Fisher-Yates shuffle
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Start music playback
        function startMusic(timerMinutes) {
            if (musicPlaylist.length === 0) {
                console.log('No music files available');
                return;
            }

            console.log('Starting music with', timerMinutes, 'minute timer');
            musicPlaying = true;
            isFadingOut = false;
            musicShuffled = shuffleArray(musicPlaylist);
            musicCurrentIndex = 0;
            musicTimerRemaining = timerMinutes * 60;

            // Show indicator
            musicIndicator.classList.add('active');

            // Update local controls UI
            updateMusicControlsUI();

            // Apply saved volume (don't reset to full)
            const savedVol = localStorage.getItem('sender-music-volume');
            musicAudio.volume = savedVol !== null ? parseInt(savedVol) / 100 : 0.5;

            // Start timer countdown
            if (musicTimer) clearInterval(musicTimer);
            musicTimer = setInterval(() => {
                musicTimerRemaining--;
                updateMusicTimerDisplay();
                if (musicTimerRemaining <= 0) {
                    console.log('Music timer expired');
                    fadeOutAndStop();
                }
            }, 1000);

            // Start status broadcast
            if (musicStatusInterval) clearInterval(musicStatusInterval);
            musicStatusInterval = setInterval(broadcastMusicStatus, 5000);

            // Play first track
            playNextTrack();

            // Activate echo cancellation if enabled
            if (echoCancelEnabled && audioContext && localStream) {
                setTimeout(async () => {
                    if (setupEchoCancellation()) {
                        await replaceAudioTrack(processedAudioTrack);
                        broadcastEchoCancelStatus();
                    }
                }, 100); // Small delay to ensure music is playing
            }

            // Broadcast initial status
            broadcastMusicStatus();
        }

        // Play next track in shuffled playlist
        function playNextTrack() {
            if (!musicPlaying || musicShuffled.length === 0) return;

            const track = musicShuffled[musicCurrentIndex];
            console.log('Playing track:', track.name);
            console.log('Audio routing - musicMediaSource exists:', !!musicMediaSource,
                        ', audioContext exists:', !!audioContext,
                        ', audioContext state:', audioContext?.state,
                        ', echoCancelEnabled:', echoCancelEnabled,
                        ', echoCancelActive:', echoCancelActive);
            musicTrackName.textContent = track.name;

            musicAudio.src = track.url;
            musicAudio.play().catch(err => {
                console.error('Music play error:', err);
            });

            // Move to next track, loop if exhausted
            musicCurrentIndex = (musicCurrentIndex + 1) % musicShuffled.length;

            // Reshuffle when we've played all tracks
            if (musicCurrentIndex === 0 && musicPlaying) {
                musicShuffled = shuffleArray(musicPlaylist);
            }
        }

        // Handle track ended - play next
        musicAudio.addEventListener('ended', () => {
            if (musicPlaying) {
                playNextTrack();
            }
        });

        // Fade out and stop music (used when timer expires or streaming stops)
        let isFadingOut = false;
        function fadeOutAndStop() {
            if (isFadingOut || !musicPlaying) return; // Prevent multiple fade outs
            isFadingOut = true;
            console.log('Fading out music...');
            const fadeInterval = 50; // ms between volume steps
            const fadeDuration = 5000; // total fade duration in ms
            const steps = fadeDuration / fadeInterval;
            const startVolume = musicAudio.volume;
            const volumeStep = startVolume / steps;

            // Clear the main timer first
            if (musicTimer) {
                clearInterval(musicTimer);
                musicTimer = null;
            }

            let currentVolume = startVolume;
            const fadeTimer = setInterval(() => {
                currentVolume -= volumeStep;
                if (currentVolume > 0.01) {
                    musicAudio.volume = currentVolume;
                } else {
                    clearInterval(fadeTimer);
                    musicAudio.volume = 0;
                    isFadingOut = false;
                    stopMusic(true); // Always broadcast (this also restores volume setting)
                }
            }, fadeInterval);
        }

        // Stop music playback
        function stopMusic(broadcast = true) {
            console.log('Stopping music');
            musicPlaying = false;
            musicAudio.pause();
            musicAudio.src = '';

            // Restore volume from saved setting for next playback
            const savedVol = localStorage.getItem('sender-music-volume');
            musicAudio.volume = savedVol !== null ? parseInt(savedVol) / 100 : 0.5;

            if (musicTimer) {
                clearInterval(musicTimer);
                musicTimer = null;
            }

            if (musicStatusInterval) {
                clearInterval(musicStatusInterval);
                musicStatusInterval = null;
            }

            musicIndicator.classList.remove('active');
            musicTimerRemaining = 0;

            // Deactivate echo cancellation and restore original audio track
            if (echoCancelActive) {
                teardownEchoCancellation();
                if (originalAudioTrack) {
                    replaceAudioTrack(originalAudioTrack);
                }
                broadcastEchoCancelStatus();
            }

            // Update local controls UI
            updateMusicControlsUI();

            if (broadcast) {
                broadcastMusicStatus();
            }
        }

        // Update timer display
        function updateMusicTimerDisplay() {
            const mins = Math.floor(musicTimerRemaining / 60);
            const secs = musicTimerRemaining % 60;
            musicTimerEl.textContent = `${mins}:${secs.toString().padStart(2, '0')} remaining`;
        }

        // Broadcast music status to receivers
        function broadcastMusicStatus() {
            if (!sseConnected) return;

            const currentTrack = musicPlaying && musicShuffled.length > 0
                ? musicShuffled[(musicCurrentIndex - 1 + musicShuffled.length) % musicShuffled.length].name
                : '';

            sendSignal({
                type: 'music-status',
                playing: musicPlaying,
                currentTrack: currentTrack,
                timerRemaining: musicTimerRemaining
            });
        }

        // Fetch playlist on load
        fetchMusicPlaylist();

        // === Echo Cancellation (FFT-based Spectral Subtraction) ===

        // Inline Radix-2 Cooley-Tukey FFT implementation (no external dependencies)
        function bitReverse(n, bits) {
            let reversed = 0;
            for (let i = 0; i < bits; i++) {
                reversed = (reversed << 1) | (n & 1);
                n >>= 1;
            }
            return reversed;
        }

        // Forward FFT (in-place, modifies real and imag arrays)
        function fftInPlace(real, imag) {
            const n = real.length;
            const bits = Math.log2(n);

            // Bit-reversal permutation
            for (let i = 0; i < n; i++) {
                const j = bitReverse(i, bits);
                if (j > i) {
                    [real[i], real[j]] = [real[j], real[i]];
                    [imag[i], imag[j]] = [imag[j], imag[i]];
                }
            }

            // Cooley-Tukey iterative FFT
            for (let size = 2; size <= n; size *= 2) {
                const halfSize = size / 2;
                const angleStep = -2 * Math.PI / size;

                for (let i = 0; i < n; i += size) {
                    for (let j = 0; j < halfSize; j++) {
                        const angle = angleStep * j;
                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);

                        const evenIdx = i + j;
                        const oddIdx = i + j + halfSize;

                        const tReal = cos * real[oddIdx] - sin * imag[oddIdx];
                        const tImag = sin * real[oddIdx] + cos * imag[oddIdx];

                        real[oddIdx] = real[evenIdx] - tReal;
                        imag[oddIdx] = imag[evenIdx] - tImag;
                        real[evenIdx] = real[evenIdx] + tReal;
                        imag[evenIdx] = imag[evenIdx] + tImag;
                    }
                }
            }
        }

        // Inverse FFT using conjugate trick
        function ifftInPlace(real, imag) {
            const n = real.length;

            // Conjugate
            for (let i = 0; i < n; i++) {
                imag[i] = -imag[i];
            }

            // Forward FFT
            fftInPlace(real, imag);

            // Conjugate and scale
            for (let i = 0; i < n; i++) {
                real[i] = real[i] / n;
                imag[i] = -imag[i] / n;
            }
        }

        // Pre-compute Hann window
        function createHannWindow(size) {
            const window = new Float32Array(size);
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / size));
            }
            return window;
        }

        // Initialize FFT state buffers
        function initFFTState() {
            const hannWindow = createHannWindow(FFT_SIZE);

            return {
                hannWindow,
                // Ring buffers for overlap-add
                inputRing: new Float32Array(FFT_SIZE),
                outputRing: new Float32Array(FFT_SIZE * 2),
                inputPos: 0,
                outputReadPos: 0,
                outputWritePos: FFT_SIZE,  // Start ahead to provide latency for overlap-add
                totalSamplesIn: 0,         // Track total input samples for first frame timing

                // FFT working arrays
                fftReal: new Float32Array(FFT_SIZE),
                fftImag: new Float32Array(FFT_SIZE),

                // Music spectrum from AnalyserNode
                musicFreqData: null, // Will be Float32Array

                // Previous frame magnitude for temporal smoothing
                prevMag: new Float32Array(FFT_SIZE / 2 + 1),

                // Performance monitoring
                overrunCount: 0,
                useSimpleMode: false,
                lastProcessTime: 0
            };
        }

        // Setup echo cancellation audio processing pipeline
        function setupEchoCancellation() {
            if (!localStream || !audioContext) {
                console.log('Echo cancel: no stream or audio context');
                return false;
            }

            const audioTrack = localStream.getAudioTracks()[0];
            if (!audioTrack) {
                console.log('Echo cancel: no audio track');
                return false;
            }

            try {
                console.log('Setting up FFT-based echo cancellation...');

                // Store original track for later restoration
                originalAudioTrack = audioTrack;

                // Initialize FFT state
                fftState = initFFTState();

                // Create analyzer for music (to get frequency spectrum)
                echoMusicAnalyser = audioContext.createAnalyser();
                echoMusicAnalyser.fftSize = FFT_SIZE;
                echoMusicAnalyser.smoothingTimeConstant = 0.3;

                // Initialize music frequency data array
                fftState.musicFreqData = new Float32Array(echoMusicAnalyser.frequencyBinCount);

                // Create mic source (store reference to prevent garbage collection)
                echoMicSource = audioContext.createMediaStreamSource(localStream);

                // Create music source if not already created
                // Note: createMediaElementSource can only be called once per element
                if (!musicMediaSource) {
                    musicMediaSource = audioContext.createMediaElementSource(musicAudio);
                }
                // Disconnect all outputs and reconnect cleanly
                try {
                    musicMediaSource.disconnect();
                } catch (e) {
                    // No existing connections, that's fine
                }
                // Reconnect to destination so music still plays
                musicMediaSource.connect(audioContext.destination);
                // Connect to analyzer for echo cancellation
                musicMediaSource.connect(echoMusicAnalyser);

                // Create processor node for spectral subtraction
                echoProcessorNode = audioContext.createScriptProcessor(PROCESSOR_BUFFER_SIZE, 1, 1);

                // Create destination for processed audio
                echoStreamDestination = audioContext.createMediaStreamDestination();

                // Connect mic source -> processor -> destination
                echoMicSource.connect(echoProcessorNode);
                echoProcessorNode.connect(echoStreamDestination);

                // Debug counter for logging
                let debugCounter = 0;

                // FFT-based spectral subtraction processing
                echoProcessorNode.onaudioprocess = (e) => {
                    const startTime = performance.now();
                    const inputData = e.inputBuffer.getChannelData(0);
                    const outputData = e.outputBuffer.getChannelData(0);
                    const bufferSize = inputData.length;

                    // Debug logging every ~2 seconds (at 48kHz, 4096 buffer = ~12 calls/sec)
                    debugCounter++;
                    if (debugCounter % 24 === 1) {
                        // Calculate RMS of input
                        let inputRms = 0;
                        for (let j = 0; j < bufferSize; j++) {
                            inputRms += inputData[j] * inputData[j];
                        }
                        inputRms = Math.sqrt(inputRms / bufferSize);
                        console.log(`Echo cancel debug: musicPlaying=${musicPlaying}, inputRms=${inputRms.toFixed(6)}, totalSamples=${fftState?.totalSamplesIn || 0}`);
                    }

                    // If music isn't playing, pass audio through unchanged
                    if (!musicPlaying) {
                        for (let i = 0; i < bufferSize; i++) {
                            outputData[i] = inputData[i];
                        }
                        return;
                    }

                    // Fallback to simple mode if FFT is too slow for this device
                    if (fftState.useSimpleMode) {
                        processSimpleMode(inputData, outputData);
                        return;
                    }

                    // Get current music spectrum
                    echoMusicAnalyser.getFloatFrequencyData(fftState.musicFreqData);

                    // Process samples through overlap-add pipeline
                    for (let i = 0; i < bufferSize; i++) {
                        // Add input sample to ring buffer
                        fftState.inputRing[fftState.inputPos] = inputData[i];
                        fftState.inputPos = (fftState.inputPos + 1) % FFT_SIZE;
                        fftState.totalSamplesIn++;

                        // Process FFT frame when we have enough samples:
                        // - First frame triggers at FFT_SIZE samples (need full buffer)
                        // - Subsequent frames trigger every HOP_SIZE samples after that
                        if (fftState.totalSamplesIn >= FFT_SIZE &&
                            (fftState.totalSamplesIn - FFT_SIZE) % HOP_SIZE === 0) {
                            processFFTFrame();
                        }

                        // Read from output ring buffer
                        outputData[i] = fftState.outputRing[fftState.outputReadPos];
                        fftState.outputRing[fftState.outputReadPos] = 0; // Clear after reading
                        fftState.outputReadPos = (fftState.outputReadPos + 1) % (FFT_SIZE * 2);
                    }

                    // Debug: log output RMS every ~2 seconds
                    if (debugCounter % 24 === 1) {
                        let outputRms = 0;
                        for (let j = 0; j < bufferSize; j++) {
                            outputRms += outputData[j] * outputData[j];
                        }
                        outputRms = Math.sqrt(outputRms / bufferSize);
                        console.log(`Echo cancel output: outputRms=${outputRms.toFixed(6)}, framesProcessed=${Math.floor((fftState.totalSamplesIn - FFT_SIZE) / HOP_SIZE) + 1}`);
                    }

                    // Performance monitoring
                    const processTime = performance.now() - startTime;
                    const budgetMs = (bufferSize / audioContext.sampleRate) * 1000;

                    if (processTime > budgetMs * 0.8) {
                        fftState.overrunCount++;
                        console.warn(`Echo cancel: processing took ${processTime.toFixed(1)}ms (budget: ${budgetMs.toFixed(1)}ms), overruns: ${fftState.overrunCount}`);

                        if (fftState.overrunCount >= MAX_OVERRUNS) {
                            console.warn('Echo cancel: switching to simple mode due to performance');
                            fftState.useSimpleMode = true;
                        }
                    }
                };

                // Get the processed audio track
                processedAudioTrack = echoStreamDestination.stream.getAudioTracks()[0];

                echoCancelActive = true;
                console.log('FFT-based echo cancellation setup complete');
                return true;

            } catch (err) {
                console.error('Echo cancellation setup error:', err);
                teardownEchoCancellation();
                return false;
            }
        }

        // Process one FFT frame with spectral subtraction
        function processFFTFrame() {
            const state = fftState;

            // Copy input with Hann windowing
            for (let i = 0; i < FFT_SIZE; i++) {
                const idx = (state.inputPos + i) % FFT_SIZE;
                state.fftReal[i] = state.inputRing[idx] * state.hannWindow[i];
                state.fftImag[i] = 0;
            }

            // Forward FFT
            fftInPlace(state.fftReal, state.fftImag);

            // Spectral subtraction per frequency bin
            // Note: AnalyserNode gives FFT_SIZE/2 bins, but FFT has FFT_SIZE/2+1 unique bins
            const numBins = FFT_SIZE / 2 + 1;
            const musicBins = state.musicFreqData.length; // FFT_SIZE / 2

            for (let k = 0; k < numBins; k++) {
                // Calculate mic magnitude and phase
                const micMag = Math.sqrt(state.fftReal[k] * state.fftReal[k] + state.fftImag[k] * state.fftImag[k]);
                const phase = Math.atan2(state.fftImag[k], state.fftReal[k]);

                // Get music magnitude from AnalyserNode (dB) and convert to linear
                // AnalyserNode returns values in dB, typically -100 to 0
                // Clamp index to avoid accessing beyond array bounds (Nyquist bin)
                const musicIdx = Math.min(k, musicBins - 1);
                const musicDb = state.musicFreqData[musicIdx];
                const musicMag = Math.pow(10, musicDb / 20) * MUSIC_SCALE;

                // Spectral subtraction with over-subtraction and spectral floor
                // outputMag = max(micMag - ALPHA * musicMag, BETA * micMag)
                let outputMag = micMag - ALPHA * musicMag;
                outputMag = Math.max(outputMag, BETA * micMag);

                // Temporal smoothing to reduce "musical noise" artifacts
                outputMag = SMOOTHING * state.prevMag[k] + (1 - SMOOTHING) * outputMag;
                state.prevMag[k] = outputMag;

                // Reconstruct complex spectrum (preserve original phase)
                state.fftReal[k] = outputMag * Math.cos(phase);
                state.fftImag[k] = outputMag * Math.sin(phase);

                // Mirror for negative frequencies (except DC and Nyquist)
                if (k > 0 && k < FFT_SIZE / 2) {
                    state.fftReal[FFT_SIZE - k] = state.fftReal[k];
                    state.fftImag[FFT_SIZE - k] = -state.fftImag[k];
                }
            }

            // Inverse FFT
            ifftInPlace(state.fftReal, state.fftImag);

            // Overlap-add to output buffer
            for (let i = 0; i < FFT_SIZE; i++) {
                const outIdx = (state.outputWritePos + i) % (FFT_SIZE * 2);
                state.outputRing[outIdx] += state.fftReal[i] * state.hannWindow[i];
            }

            // Advance write position by hop size
            state.outputWritePos = (state.outputWritePos + HOP_SIZE) % (FFT_SIZE * 2);
        }

        // Simple fallback mode (original energy-based suppression)
        function processSimpleMode(inputData, outputData) {
            // Get music energy from analyser
            echoMusicAnalyser.getFloatFrequencyData(fftState.musicFreqData);

            let musicEnergy = 0;
            for (let i = 0; i < fftState.musicFreqData.length; i++) {
                const linear = Math.pow(10, fftState.musicFreqData[i] / 20);
                musicEnergy += linear;
            }
            musicEnergy = musicEnergy / fftState.musicFreqData.length;

            const suppressionFactor = Math.min(1, musicEnergy * 7);

            for (let i = 0; i < inputData.length; i++) {
                outputData[i] = inputData[i] * (1 - suppressionFactor * 0.7);
            }
        }

        // Teardown echo cancellation
        function teardownEchoCancellation() {
            console.log('Tearing down echo cancellation...');

            if (echoProcessorNode) {
                echoProcessorNode.disconnect();
                echoProcessorNode.onaudioprocess = null;
                echoProcessorNode = null;
            }

            if (echoMicSource) {
                echoMicSource.disconnect();
                echoMicSource = null;
            }

            // Don't disconnect musicMediaSource - it needs to stay connected for playback
            // Just disconnect from the echo analyzer
            if (echoMusicAnalyser) {
                echoMusicAnalyser.disconnect();
                echoMusicAnalyser = null;
            }

            if (echoStreamDestination) {
                echoStreamDestination = null;
            }

            // Clean up FFT state
            fftState = null;

            processedAudioTrack = null;
            echoCancelActive = false;
            console.log('Echo cancellation teardown complete');
        }

        // Handle echo cancel toggle from receiver
        async function handleEchoCancelToggle(enabled) {
            console.log('Echo cancel toggle:', enabled);
            echoCancelEnabled = enabled;

            if (enabled && musicPlaying) {
                // Setup and activate echo cancellation
                if (setupEchoCancellation()) {
                    // Replace audio track in WebRTC connection
                    await replaceAudioTrack(processedAudioTrack);
                }
            } else {
                // Teardown and restore original audio
                teardownEchoCancellation();
                if (originalAudioTrack) {
                    await replaceAudioTrack(originalAudioTrack);
                }
            }

            // Broadcast status to receivers
            broadcastEchoCancelStatus();
        }

        // Replace audio track in peer connection
        async function replaceAudioTrack(newTrack) {
            if (!peerConnection || !newTrack) return;

            const senders = peerConnection.getSenders();
            const audioSender = senders.find(s => s.track && s.track.kind === 'audio');

            if (audioSender) {
                try {
                    await audioSender.replaceTrack(newTrack);
                    console.log('Replaced audio track');
                } catch (err) {
                    console.error('Failed to replace audio track:', err);
                }
            }
        }

        // Broadcast echo cancel status to receivers
        function broadcastEchoCancelStatus() {
            if (!sseConnected) return;

            sendSignal({
                type: 'echo-cancel-status',
                enabled: echoCancelEnabled,
                active: echoCancelActive
            });
        }

        // Public STUN servers (only used for IP discovery, no media passes through)
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.stunprotocol.org:3478' },
                { urls: 'stun:stun.nextcloud.com:443' },
                { urls: 'stun:stun.sipgate.net:3478' }
            ],
            iceCandidatePoolSize: 10
        };

        // Send signal via HTTP POST (replaces WebSocket send)
        async function sendSignal(message) {
            message.role = 'sender';
            message.session = sessionName; // Include session for routing
            try {
                const response = await fetch('/api/signal', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(message)
                });
                if (!response.ok) {
                    console.error('Signal failed:', response.status);
                }
            } catch (err) {
                console.error('Signal error:', err);
            }
        }

        function setConnectedState(connected) {
            if (connected) {
                document.body.classList.add('connected');
                document.body.classList.remove('disconnected');
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                document.body.classList.remove('connected');
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
            }
        }

        function setDisconnectedState() {
            document.body.classList.add('disconnected');
            document.body.classList.remove('connected');
            statusDot.classList.remove('connected');
            statusText.textContent = 'Disconnected!';
        }

        function connectSSE() {
            // Close existing connection
            if (eventSource) {
                eventSource.close();
            }

            const sseUrl = `/api/sse/sender/${encodeURIComponent(sessionName)}`;
            console.log('Connecting to SSE:', sseUrl);

            eventSource = new EventSource(sseUrl);

            eventSource.onopen = () => {
                console.log('SSE connected');
            };

            eventSource.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                if (message.type !== 'heartbeat') {
                    console.log('Sender received:', message.type);
                }

                switch (message.type) {
                    case 'registered':
                        console.log('Registered as sender');
                        sseConnected = true;
                        info.textContent = 'Connected to server. Auto-starting stream...';
                        // Auto-start streaming
                        if (!isStreaming) {
                            setTimeout(() => startStreaming(), 500);
                        }
                        // Broadcast current status to sync receivers on reconnect
                        setTimeout(() => {
                            broadcastMusicStatus();
                            broadcastEchoCancelStatus();
                        }, 1000);
                        break;

                    case 'error':
                        alert(message.message);
                        window.location.href = '/';
                        break;

                    case 'replaced':
                        // Another sender took over this session
                        console.log('Replaced by another sender');
                        sseConnected = false;
                        eventSource.close();
                        info.textContent = 'Another device took over as sender. Refresh to reclaim.';
                        setDisconnectedState();
                        break;

                    case 'request-offer':
                        console.log('Receiver requesting offer, videoEnabled:', message.videoEnabled);
                        // Update video preference if specified
                        if (message.videoEnabled !== undefined) {
                            receiverWantsVideo = message.videoEnabled;
                            updateStreamingStatus();
                        }
                        if (localStream) {
                            await createOffer();
                            // Send current music status to newly connected receiver
                            broadcastMusicStatus();
                        } else {
                            console.log('No local stream yet');
                        }
                        break;

                    case 'video-request':
                        console.log('Receiver video request:', message.enabled);
                        receiverWantsVideo = message.enabled;
                        updateStreamingStatus();
                        // Renegotiate connection with updated video state
                        if (localStream && peerConnection) {
                            await createOffer();
                        }
                        break;

                    case 'answer':
                        console.log('Received answer');
                        if (peerConnection && peerConnection.signalingState === 'have-local-offer') {
                            try {
                                await peerConnection.setRemoteDescription(new RTCSessionDescription(message.answer));
                                console.log('Remote description set');

                                // Process any queued ICE candidates
                                console.log('Processing', pendingCandidates.length, 'queued ICE candidates');
                                for (const candidate of pendingCandidates) {
                                    try {
                                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                    } catch (err) {
                                        console.log('Queued ICE candidate error:', err.message);
                                    }
                                }
                                pendingCandidates = [];
                            } catch (err) {
                                console.error('Error setting remote description:', err);
                            }
                        }
                        break;

                    case 'ice-candidate':
                        if (message.candidate) {
                            if (peerConnection && peerConnection.remoteDescription) {
                                try {
                                    await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
                                    console.log('Added ICE candidate from receiver');
                                } catch (err) {
                                    console.log('ICE candidate skipped (may be from old session)');
                                }
                            } else {
                                console.log('Queuing ICE candidate from receiver');
                                pendingCandidates.push(message.candidate);
                            }
                        }
                        break;

                    case 'no-receivers':
                        info.textContent = 'No receivers connected. Waiting...';
                        break;

                    case 'ptt-start':
                        console.log('Received PTT start from parent');
                        pttActive = true;
                        showPTTIndicator();
                        break;

                    case 'ptt-offer':
                        console.log('Received PTT offer from parent');
                        console.log('Current peer connection state:', peerConnection?.signalingState);
                        showPTTIndicator();
                        await handlePTTOffer(message.offer);
                        break;

                    case 'ptt-stop':
                        console.log('Received PTT stop from parent');
                        pttActive = false;
                        hidePTTIndicator();
                        break;

                    case 'music-start':
                        console.log('Received music start:', message.timerMinutes, 'minutes, playlist:', message.playlist);
                        // Switch playlist if specified and different
                        if (message.playlist && message.playlist !== currentPlaylistId) {
                            currentPlaylistId = message.playlist;
                            localStorage.setItem('sender-music-playlist', currentPlaylistId);
                            if (musicPlaylistSelect.value !== currentPlaylistId) {
                                musicPlaylistSelect.value = currentPlaylistId;
                            }
                            // Fetch new playlist then start
                            fetchMusicPlaylist(currentPlaylistId).then(() => {
                                startMusic(message.timerMinutes);
                            });
                        } else {
                            startMusic(message.timerMinutes);
                        }
                        break;

                    case 'music-stop':
                        console.log('Received music stop');
                        fadeOutAndStop();
                        break;

                    case 'music-timer-reset':
                        console.log('Received music timer reset:', message.timerMinutes, 'minutes');
                        if (musicPlaying) {
                            musicTimerRemaining = message.timerMinutes * 60;
                            updateMusicTimerDisplay();
                            broadcastMusicStatus();
                        }
                        break;

                    case 'echo-cancel-enable':
                        console.log('Received echo cancel toggle:', message.enabled);
                        handleEchoCancelToggle(message.enabled);
                        break;

                    case 'heartbeat':
                        // Server heartbeat - connection is alive
                        break;
                }
            };

            eventSource.onerror = (err) => {
                console.error('SSE error:', err);
                sseConnected = false;
                setDisconnectedState();
                // Reconnect after delay
                eventSource.close();
                setTimeout(connectSSE, 3000);
            };
        }

        async function startStreaming() {
            try {
                // Video resolution based on quality setting
                const videoResolution = videoQuality === 'sd'
                    ? { width: { ideal: 640 }, height: { ideal: 480 } }
                    : { width: { ideal: 1280 }, height: { ideal: 720 } };

                const constraints = {
                    video: enableVideo.checked ? {
                        facingMode: 'environment',
                        ...videoResolution
                    } : false,
                    audio: enableAudio.checked ? {
                        echoCancellation: true,
                        noiseSuppression: true
                    } : false
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;

                console.log('Got local stream');
                console.log('Video tracks:', localStream.getVideoTracks().length);
                console.log('Audio tracks:', localStream.getAudioTracks().length);

                if (localStream.getVideoTracks().length > 0) {
                    const videoTrack = localStream.getVideoTracks()[0];
                    console.log('Video track settings:', videoTrack.getSettings());
                }

                // Setup audio analysis
                if (enableAudio.checked) {
                    setupAudioAnalysis(localStream);
                }

                startBtn.style.display = 'none';
                stopBtn.style.display = 'block';
                optionsPanel.style.display = 'none';
                streamingStatus.style.display = 'flex';
                isStreaming = true;
                updateStreamingStatus();

                info.textContent = 'Streaming... Waiting for receivers.';
                setConnectedState(true);

                // Auto-enable audio for PTT playback
                enableAudioPlayback();

                // Create offer for any existing receivers
                await createOffer();

            } catch (err) {
                console.error('Error starting stream:', err);
                alert('Failed to access camera/microphone: ' + err.message);
            }
        }

        async function createOffer() {
            // Close existing connection if any
            if (peerConnection) {
                peerConnection.close();
            }

            // Clear any pending candidates from previous session
            pendingCandidates = [];

            peerConnection = new RTCPeerConnection(rtcConfig);
            console.log('Created new peer connection');

            localStream.getTracks().forEach(track => {
                // Skip video track if receiver requested audio-only
                if (track.kind === 'video' && !receiverWantsVideo) {
                    console.log('Skipping video track (receiver requested audio-only)');
                    return;
                }
                peerConnection.addTrack(track, localStream);
                console.log('Added track:', track.kind);
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate && sseConnected) {
                    console.log('Sending ICE candidate');
                    sendSignal({
                        type: 'ice-candidate',
                        candidate: event.candidate
                    });
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    setConnectedState(true);
                    info.textContent = 'Connected to receiver!';
                } else if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
                    info.textContent = 'Receiver disconnected. Waiting...';
                }
            };

            // Handle incoming audio from parent (PTT)
            peerConnection.ontrack = (event) => {
                console.log('Received track from parent:', event.track.kind, event.streams, 'pttActive:', pttActive);
                if (event.track.kind === 'audio' && event.streams[0] !== localStream) {
                    console.log('PTT audio track received, setting up playback');
                    pttAudio.srcObject = event.streams[0];
                    
                    // Only show indicator if PTT is supposed to be active
                    if (pttActive) {
                        showPTTIndicator();
                    }

                    // Force play
                    pttAudio.play().then(() => {
                        console.log('PTT audio playing');
                    }).catch(err => {
                        console.error('PTT audio play error:', err);
                        // Try again after a short delay
                        setTimeout(() => pttAudio.play().catch(() => {}), 100);
                    });

                    // Hide indicator when track ends (backup)
                    event.track.onended = () => {
                        console.log('PTT track ended');
                        pttActive = false;
                        hidePTTIndicator();
                        pttAudio.srcObject = null;
                    };

                    event.track.onmute = () => {
                        console.log('PTT track muted');
                        // Don't hide here - let WebSocket message control it
                    };

                    event.track.onunmute = () => {
                        console.log('PTT track unmuted, pttActive:', pttActive);
                        // Only show indicator if PTT is supposed to be active
                        if (pttActive) {
                            showPTTIndicator();
                            pttAudio.play().catch(e => console.log('Play on unmute error:', e));
                        }
                    };
                }
            };

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                console.log('Created and set local offer');

                if (sseConnected) {
                    sendSignal({
                        type: 'offer',
                        offer: peerConnection.localDescription
                    });
                    console.log('Sent offer to server');
                }
            } catch (err) {
                console.error('Error creating offer:', err);
            }
        }

        function stopStreaming() {
            // Teardown echo cancellation first
            if (echoCancelActive) {
                teardownEchoCancellation();
            }

            // Fade out music if playing
            if (musicPlaying) {
                fadeOutAndStop();
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            localVideo.srcObject = null;

            startBtn.style.display = 'block';
            stopBtn.style.display = 'none';
            optionsPanel.style.display = 'flex';
            streamingStatus.style.display = 'none';
            isStreaming = false;
            receiverWantsVideo = true; // Reset for next session
            echoCancelEnabled = false; // Reset echo cancel state
            originalAudioTrack = null;
            processedAudioTrack = null;

            // NOTE: Don't close audioContext or reset musicMediaSource here!
            // Once createMediaElementSource() is called on musicAudio, that element
            // is permanently bound to that context. Closing the context would break
            // music playback. The context and musicMediaSource must persist.

            setConnectedState(false);
            info.textContent = 'Streaming stopped.';
        }

        function setupAudioAnalysis(stream) {
            // Reuse existing audioContext if available (required if musicMediaSource exists)
            // Once createMediaElementSource() is called, that element is bound to its context
            if (!audioContext || audioContext.state === 'closed') {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;

            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            function updateAudioLevel() {
                if (!analyser) return;

                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                const percentage = Math.min(100, (average / 128) * 100);

                audioLevel.style.width = percentage + '%';

                requestAnimationFrame(updateAudioLevel);
            }

            updateAudioLevel();
        }

        // Handle PTT offer from parent
        async function handlePTTOffer(offer) {
            if (!peerConnection) {
                console.log('No peer connection for PTT');
                return;
            }

            try {
                console.log('Processing PTT offer, signaling state:', peerConnection.signalingState);

                // Handle glare (both sides sending offers)
                if (peerConnection.signalingState !== 'stable') {
                    console.log('Waiting for stable state...');
                    await new Promise(resolve => {
                        const checkState = () => {
                            if (peerConnection.signalingState === 'stable') {
                                resolve();
                            } else {
                                setTimeout(checkState, 100);
                            }
                        };
                        checkState();
                    });
                }

                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                console.log('Set remote description for PTT');

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Created PTT answer');

                if (sseConnected) {
                    sendSignal({
                        type: 'ptt-answer',
                        answer: peerConnection.localDescription
                    });
                    console.log('Sent PTT answer');
                }
            } catch (err) {
                console.error('PTT offer error:', err);
            }
        }

        // Update streaming status display
        function updateStreamingStatus() {
            if (!isStreaming) return;

            const hasVideo = enableVideo.checked && receiverWantsVideo;
            const hasAudio = enableAudio.checked;

            if (hasVideo && hasAudio) {
                streamingStatusValue.textContent = 'Video + Audio';
                streamingStatusValue.className = 'status-value';
            } else if (hasVideo) {
                streamingStatusValue.textContent = 'Video only';
                streamingStatusValue.className = 'status-value';
            } else if (hasAudio) {
                streamingStatusValue.textContent = 'Audio only';
                streamingStatusValue.className = 'status-value audio-only';
            } else {
                streamingStatusValue.textContent = 'Nothing';
                streamingStatusValue.className = 'status-value';
            }
        }

        // PTT indicator helper functions with timeout fallback
        function showPTTIndicator() {
            // Clear any existing timeout
            if (pttTimeout) {
                clearTimeout(pttTimeout);
            }
            pttIndicator.classList.add('active');
            
            // Set fallback timeout - if no stop message received, hide after 30 seconds
            pttTimeout = setTimeout(() => {
                console.log('PTT timeout - hiding indicator');
                hidePTTIndicator();
            }, PTT_TIMEOUT_MS);
        }
        
        function hidePTTIndicator() {
            if (pttTimeout) {
                clearTimeout(pttTimeout);
                pttTimeout = null;
            }
            pttIndicator.classList.remove('active');
        }

        // Auto-enable audio playback for PTT
        let audioEnabled = false;
        function enableAudioPlayback() {
            if (audioEnabled) return;
            audioEnabled = true;
            console.log('Audio playback enabled');

            // Create and play a silent audio to unlock audio context
            const silentAudio = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
            silentAudio.play().catch(e => {});
            
            // Also try to resume any suspended audio context
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            if (pttAudio.srcObject) {
                pttAudio.play().catch(e => console.log('PTT play after enable:', e));
            }
        }

        // Enable audio on any user interaction (fallback)
        document.addEventListener('click', enableAudioPlayback, { passive: true });
        document.addEventListener('touchstart', enableAudioPlayback, { passive: true });
        document.addEventListener('touchend', enableAudioPlayback, { passive: true });

        startBtn.addEventListener('click', startStreaming);
        stopBtn.addEventListener('click', stopStreaming);

        // Initialize - connect SSE immediately
        connectSSE();
        
        // Try to enable audio on page load (won't work without interaction, but worth trying)
        enableAudioPlayback();
    </script>
</body>
</html>